* 목표: 배열 재할당, 라인 단위 입력과 문자열 tokenizing
	
	사람이름과 번호를 저장하는 배열을 100으로 고정했지만. 초과하게 되면 v2.0에선 아무런 대책이 없다.
	배열이란 항상 크기를 지정해야하는데 이제는 모자란 상황이 안생기게 자료구조를 바꿔보자.

	인터페이스를 좀 개선해서 잘못된 단어를 입력하면 메세지를 출력해서 알려주게 하자.

	- 잘못된 명령어를 입력한다면, 적절한대응을하자 (read 엔터 후 다음 문자열을 입력할때까지 대기중. 이것은 올바르지않다)
		$ read
		File name required!  <- 바로바로 적절한 오류메세지를 출력하고 다음 프롬프트로 이동.

	- tokenizing
		구분문자(delimiter)를 이용하여 하나의 긴 문자열을 작은 문자열들로 자르는 일을 문자열 tokenizing이라고 부른다. 
		잘라진 작은 문자열들을 보통 token이라고 부른다. - read_line() 다음에 처리됨.
		C언어에서는 주로 strtok함수를 이용한다.
		token = strtok(문자열시작주소, 구분자)   - 이어진 sttok호출은 strtok(NULL, 구분자)를 사용합니다.
		또 첫번째 token이 끝나는 시점에 \0를 새로씁니다. - 원본문자열배열편집. (더나아가 스트링리터럴 char* 은 주소로 전달이 불가능합니다)
		따라서 원본에 편집하고 원본을 읽어오는 모양이므로 strtok는 새로운 배열을 생성하지않습니다!!  <-> _strdup()

* 프로그램 설계:

	- 최초에 명령어라인을 받을때 단어단위로 저장하지말고 문자열라인으로 처리. - char *fgets( char *string, int n, FILE *stream );
		(fgets, getline 쓰기보다는 직접많이 만들어서 쓰는 경우가 있습니다. int getchar() 사용.)
	- init_directory() 배열 names와 numbers를 생성하는 함수.
	- process_command() 사용자의 명령을 받아 처리하는 부분을 별개의 함수로 만들었다.
	- 몇개의 단어를 입력하든 한줄에 입력된 모든 문자열을 읽어봐서 처리하는 단계가 필요합니다. (tokenizing).
	- 마지막으로 이름과 전화번호가 저장된 메모리 주소를 저장하고있는 배열의 크기가 부족하게 되면 새로운 배열을 할당받고 그곳에다 복사한뒤 
		기존의 배열은 할당을 해제해주고 char **names, **numbers가 해당 배열의 첫주소를 가리키도록 하는 함수를 정의합니다. - reallocate()

* 자료구조:

	- 이전에 사용했던 names과 numbers를 배열로 선언하면 안되고 포인터로 선언해야합니다. (char **names, char **numbers).
		names는 char *타입의 배열의 이름이므로 char **타입의 변수입니다. <- 조금만 생각해봐도 이해가 됩니다.